# 유클리드 거리 기반 얼굴 인식

## 1. 유클리드 거리란?

유클리드 거리(Euclidean Distance)는 다차원 공간에서 두 점 사이의 직선 거리를 측정하는 방법입니다. 2차원 평면에서의 두 점 사이 거리를 계산하는 피타고라스 정리를 n차원으로 확장한 개념입니다.

### 1.1 수학적 정의

n차원 공간에서 두 점 P = (p1, p2, ..., pn)과 Q = (q1, q2, ..., qn) 사이의 유클리드 거리는 다음과 같이 계산됩니다:

```
d(P, Q) = √[(p1-q1)² + (p2-q2)² + ... + (pn-qn)²]
```

일반화된 공식:

```
d(P, Q) = √[Σ(pi - qi)²]  (i = 1 to n)
```

### 1.2 차원별 예시

**1차원 (직선):**

```
점 A = 3, 점 B = 7
거리 = |7 - 3| = 4
```

**2차원 (평면):**

```
점 A = (1, 2), 점 B = (4, 6)
거리 = √[(4-1)² + (6-2)²]
     = √[9 + 16]
     = √25
     = 5
```

**3차원 (공간):**

```
점 A = (1, 2, 3), 점 B = (4, 6, 8)
거리 = √[(4-1)² + (6-2)² + (8-3)²]
     = √[9 + 16 + 25]
     = √50
     ≈ 7.07
```

## 2. 얼굴 인식에서의 유클리드 거리

### 2.1 얼굴의 벡터 표현

얼굴 인식 시스템은 각 얼굴을 고차원 벡터(descriptor)로 변환합니다. 이 프로젝트에서는:

- 딥러닝 모델(FaceRecognitionNet)을 사용하여 얼굴을 128차원 벡터로 변환
- 각 차원은 얼굴의 특정 특징을 수치로 표현
- Float32Array 형태로 저장됨

```
얼굴 A = [0.23, -0.45, 0.67, ..., 0.12]  (128개 값)
얼굴 B = [0.21, -0.43, 0.69, ..., 0.15]  (128개 값)
```

### 2.2 유사도 계산 원리

두 얼굴 벡터 간의 유클리드 거리를 계산하면:

```
거리 = √[(A1-B1)² + (A2-B2)² + ... + (A128-B128)²]
```

**거리의 의미:**

- 거리가 0에 가까움: 두 얼굴이 매우 유사 (같은 사람일 가능성 높음)
- 거리가 큼: 두 얼굴이 다름 (다른 사람일 가능성 높음)

### 2.3 코드에서의 구현

프로젝트의 `calculateDistance` 함수:

```typescript
export function calculateDistance(
  desc1: Float32Array,
  desc2: Float32Array
): number {
  return faceapi.euclideanDistance(desc1, desc2);
}
```

이 함수는 내부적으로 다음과 같이 계산합니다:

```javascript
function euclideanDistance(arr1, arr2) {
  let sum = 0;
  for (let i = 0; i < arr1.length; i++) {
    const diff = arr1[i] - arr2[i];
    sum += diff * diff;
  }
  return Math.sqrt(sum);
}
```

## 3. 매칭 프로세스

### 3.1 전체 흐름

1. **얼굴 검출**: 이미지에서 얼굴 찾기
2. **벡터 변환**: 각 얼굴을 128차원 벡터로 변환
3. **거리 계산**: 기준 얼굴과 대상 얼굴들 간의 유클리드 거리 계산
4. **매칭 판단**: 임계값(threshold)과 비교하여 매칭 여부 결정

### 3.2 임계값 (Threshold)

프로젝트에서는 **0.6**을 기본 임계값으로 사용:

```typescript
export function findMatchingPhotos(
  myDescriptor: Float32Array,
  photos: MarathonPhoto[],
  threshold: number = 0.6
): MatchResult[] {
  // ...
  if (minDistance <= threshold) {
    // 매칭 성공
  }
}
```

**임계값의 의미:**

- 0.6 이하: 같은 사람으로 판단
- 0.6 초과: 다른 사람으로 판단

**임계값 조정 효과:**

- 낮게 설정 (예: 0.4): 더 엄격한 매칭, 정확도 상승, 검출률 하락
- 높게 설정 (예: 0.8): 더 관대한 매칭, 검출률 상승, 오탐률 상승

### 3.3 유사도 점수 변환

거리를 0~1 범위의 직관적인 점수로 변환:

```typescript
const score = Math.max(0, 1 - minDistance);
```

**점수 의미:**

- 1.0 (100%): 완벽히 일치
- 0.7 (70%): 높은 유사도
- 0.4 (40%): 낮은 유사도
- 0.0 (0%): 전혀 다름

**예시:**

```
거리 = 0.0  → 점수 = 1.0 (100%)
거리 = 0.3  → 점수 = 0.7 (70%)
거리 = 0.6  → 점수 = 0.4 (40%)
거리 = 1.0  → 점수 = 0.0 (0%)
```

## 4. 실제 적용 예시

### 4.1 시나리오

마라톤 대회에서 찍힌 100장의 사진 중 내가 나온 사진을 찾는 경우:

**기준 얼굴:**

```
내 얼굴 벡터 = [0.23, -0.45, 0.67, ..., 0.12]
```

**대회 사진들:**

```
사진1: 3명의 얼굴 검출
  - 얼굴1: 거리 = 0.35 → 매칭 (같은 사람)
  - 얼굴2: 거리 = 0.82 → 매칭 실패
  - 얼굴3: 거리 = 0.91 → 매칭 실패
  최소 거리 = 0.35 → 점수 = 0.65 (65%)

사진2: 2명의 얼굴 검출
  - 얼굴1: 거리 = 0.78 → 매칭 실패
  - 얼굴2: 거리 = 0.85 → 매칭 실패
  최소 거리 = 0.78 → 매칭 제외

사진3: 1명의 얼굴 검출
  - 얼굴1: 거리 = 0.28 → 매칭 (같은 사람)
  최소 거리 = 0.28 → 점수 = 0.72 (72%)
```

**결과:**

```
매칭된 사진:
1. 사진3: 72% 유사도
2. 사진1: 65% 유사도
```

### 4.2 코드 흐름

```typescript
// 1. 기준 얼굴 추출
const myDescriptor = await extractReferenceFace(referencePhoto);

// 2. 대회 사진들에서 얼굴 검출
for (const photo of marathonPhotos) {
  photo.faces = await detectFacesInImage(photo.file);
}

// 3. 매칭 수행
const results = findMatchingPhotos(myDescriptor, marathonPhotos, 0.6);

// 4. 결과 표시 (점수 높은 순)
results.forEach((result) => {
  console.log(`${result.photo.name}: ${(result.score * 100).toFixed(0)}%`);
});
```

## 5. 유클리드 거리의 장단점

### 5.1 장점

**계산 효율성**

- 간단한 수학 연산으로 빠른 계산 가능
- 실시간 처리에 적합

**직관성**

- 거리 개념이 직관적
- 결과 해석이 쉬움

**일반성**

- 모든 차원의 벡터에 적용 가능
- 다양한 머신러닝 알고리즘에서 활용

### 5.2 단점

**차원의 저주**

- 고차원 공간에서는 거리 개념이 왜곡될 수 있음
- 128차원에서는 대부분의 점들이 비슷한 거리를 가질 수 있음

**스케일 민감성**

- 각 차원의 스케일이 다르면 결과가 왜곡됨
- 정규화(normalization)가 중요

**이상치 영향**

- 한 차원의 큰 차이가 전체 거리에 큰 영향
- 제곱 연산으로 이상치의 영향이 증폭됨

## 6. 대안적 거리 측정 방법

### 6.1 코사인 유사도 (Cosine Similarity)

벡터 간의 각도를 측정:

```
similarity = (A · B) / (||A|| × ||B||)
```

**특징:**

- 방향만 고려, 크기는 무시
- -1 ~ 1 범위의 값
- 텍스트 유사도에 많이 사용

### 6.2 맨해튼 거리 (Manhattan Distance)

각 차원의 절대 차이의 합:

```
d(P, Q) = Σ|pi - qi|
```

**특징:**

- 직각 이동만 고려
- 계산이 더 간단 (제곱근 불필요)
- 격자 구조에서 유용

### 6.3 민코프스키 거리 (Minkowski Distance)

유클리드와 맨해튼의 일반화:

```
d(P, Q) = (Σ|pi - qi|^p)^(1/p)
```

- p = 1: 맨해튼 거리
- p = 2: 유클리드 거리
- p = ∞: 체비셰프 거리

## 7. 성능 최적화

### 7.1 이미지 리사이즈

계산 부하를 줄이기 위해 이미지 크기 조정:

```typescript
function resizeImage(img: HTMLImageElement, maxSize: number = 800) {
  // 긴 변을 800px로 제한
  // 얼굴 검출 정확도는 유지하면서 속도 향상
}
```

### 7.2 조기 종료

사진별 최소 거리만 필요:

```typescript
const distances = photo.faces.map((face) =>
  calculateDistance(myDescriptor, face.descriptor)
);
const minDistance = Math.min(...distances);
// 모든 얼굴을 확인할 필요 없이 최소값만 사용
```

### 7.3 병렬 처리

여러 사진을 동시에 처리:

```typescript
const results = await Promise.all(
  photos.map(async (photo) => {
    photo.faces = await detectFacesInImage(photo.file);
    return photo;
  })
);
```

## 8. 정확도 향상 방법

### 8.1 좋은 기준 사진 선택

- 정면 얼굴
- 충분한 조명
- 고해상도
- 가림 없음 (마스크, 선글라스 X)

### 8.2 임계값 조정

데이터셋 특성에 맞게 조정:

```typescript
// 엄격한 매칭
findMatchingPhotos(descriptor, photos, 0.4);

// 일반적인 매칭
findMatchingPhotos(descriptor, photos, 0.6);

// 관대한 매칭
findMatchingPhotos(descriptor, photos, 0.8);
```

### 8.3 앙상블 방법

여러 조건을 결합:

```typescript
// 거리 + 나이 + 성별 필터링
const isMatch =
  distance <= 0.6 &&
  Math.abs(face.age - referenceAge) <= 10 &&
  face.gender === referenceGender;
```

## 9. 실전 팁

### 9.1 디버깅

거리 값 확인으로 문제 진단:

```typescript
console.log("거리:", distance);
// 0.0 ~ 0.4: 매우 유사 (같은 사람일 확률 높음)
// 0.4 ~ 0.6: 유사 (같은 사람일 수 있음)
// 0.6 ~ 1.0: 다름 (다른 사람일 확률 높음)
// 1.0 이상: 매우 다름 (확실히 다른 사람)
```

### 9.2 에러 처리

얼굴 미검출 처리:

```typescript
const faces = await detectFacesInImage(file);
if (faces.length === 0) {
  console.warn("얼굴이 검출되지 않았습니다.");
  return null;
}
```

### 9.3 사용자 피드백

신뢰도 표시:

```typescript
const confidence = Math.round(result.score * 100);
console.log(`매칭 신뢰도: ${confidence}%`);
// 70% 이상: 높은 신뢰도
// 50-70%: 보통 신뢰도
// 50% 미만: 낮은 신뢰도
```

## 10. 요약

유클리드 거리는 얼굴 인식에서 두 얼굴의 유사도를 측정하는 핵심 방법입니다.

**핵심 개념:**

- 128차원 벡터 공간에서 두 점 사이의 직선 거리
- 거리가 가까울수록 유사한 얼굴
- 임계값을 기준으로 같은 사람 여부 판단

**실용적 활용:**

- 기준 얼굴과 대회 사진들을 비교
- 임계값(0.6) 이하인 사진만 매칭
- 유사도 점수로 순위 매기기

**주의사항:**

- 좋은 품질의 기준 사진 필요
- 적절한 임계값 설정 중요
- 조명, 각도, 표정 변화에 민감할 수 있음
